<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√©tamorph Optimizer - Cobblemon</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 30px;
            text-align: center;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 30px;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .input-section, .results-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            border: 1px solid #e9ecef;
        }

        h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }

        .instructions {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .instructions h3 {
            color: #856404;
            margin-bottom: 10px;
        }

        .instructions ul {
            padding-left: 20px;
        }

        .instructions li {
            margin-bottom: 8px;
        }

        .ditto-counter {
            text-align: center;
            margin-bottom: 15px;
            font-weight: bold;
            color: #2c3e50;
        }

        .import-export {
            background: #e8f4fd;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #b8daff;
        }

        .import-export h4 {
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .import-export-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .import-export-buttons button {
            flex: 1;
        }

        .ditto-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            max-height: 600px;
            overflow-y: auto;
            padding: 10px;
        }

        .ditto-card {
            background: white;
            border: 2px solid #bdc3c7;
            border-radius: 8px;
            padding: 15px;
            transition: all 0.3s ease;
        }

        .ditto-card:hover {
            border-color: #3498db;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .ditto-card h3 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .iv-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 10px;
        }

        .iv-input {
            display: flex;
            flex-direction: column;
        }

        .iv-input label {
            font-size: 0.8em;
            font-weight: bold;
            color: #7f8c8d;
            margin-bottom: 3px;
        }

        .iv-input input {
            padding: 8px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-size: 0.9em;
            width: 100%;
        }

        .iv-input input:focus {
            outline: none;
            border-color: #3498db;
        }

        .buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        button {
            padding: 12px 25px;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-optimize {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
            flex: 1;
        }

        .btn-optimize:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.4);
        }

        .btn-reset {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            flex: 1;
        }

        .btn-reset:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.4);
        }

        .btn-export {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        .btn-import {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
        }

        .optimization-info {
            background: #e8f4fd;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-label {
            font-weight: bold;
            color: #2c3e50;
        }

        .results-container {
            max-height: 600px;
            overflow-y: auto;
            padding: 10px;
        }

        .couple-card {
            background: white;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .couple-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }

        .couple-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .couple-score {
            background: #3498db;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 1.1em;
        }

        .parents {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 15px;
        }

        .parent {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 6px;
        }

        .parent h4 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .iv-display {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            font-size: 0.9em;
        }

        .iv-value {
            text-align: center;
            padding: 5px;
            border-radius: 4px;
            font-weight: bold;
        }

        .iv-31 {
            background: #27ae60;
            color: white;
        }

        .iv-other {
            background: #e74c3c;
            color: white;
        }

        .item-display {
            background: #3498db;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
            margin-top: 5px;
            display: inline-block;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2em;
            color: #7f8c8d;
        }

        .couple-info {
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            font-size: 0.9em;
        }

        .strategy-info {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
            padding: 8px;
            margin-top: 8px;
            font-size: 0.85em;
        }

        .footer {
            background: #2c3e50;
            color: white;
            text-align: center;
            padding: 20px;
            font-size: 0.9em;
        }

        .selection-info {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            color: #155724;
        }

        .unused-ditto {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            color: #721c24;
        }

        .unused-ditto h4 {
            margin-bottom: 10px;
            color: #721c24;
        }

        .items-summary {
            background: #e8f4fd;
            border: 1px solid #b8daff;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .items-summary h4 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .item-assignment {
            background: white;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #bdc3c7;
        }

        .item-assignment h5 {
            margin-bottom: 5px;
            color: #2c3e50;
        }

        .error-message {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            color: #721c24;
        }

        .probability-info {
            font-size: 0.8em;
            color: #7f8c8d;
            margin-top: 5px;
        }

        .binary-display {
            font-family: monospace;
            font-size: 1.1em;
            letter-spacing: 2px;
            margin: 5px 0;
        }

        .no-31-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
            padding: 8px;
            margin-top: 5px;
            font-size: 0.8em;
            color: #856404;
        }

        .server-mechanics {
            background: #e8f4fd;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .server-mechanics h3 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .mechanics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .mechanic-item {
            background: white;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #bdc3c7;
        }

        .mechanic-item h4 {
            color: #2c3e50;
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üî¨ M√©tamorph Optimizer</h1>
            <p class="subtitle">Optimis√© pour les m√©caniques sp√©cifiques de votre serveur Cobblemon</p>
        </header>

        <div class="main-content">
            <div class="input-section">
                <h2>üìä Entrez vos M√©tamorph</h2>
                
                <div class="server-mechanics">
                    <h3>üéØ M√©caniques Sp√©cifiques du Serveur</h3>
                    <div class="mechanics-grid">
                        <div class="mechanic-item">
                            <h4>Destiny Knot</h4>
                            <p>5 IVs h√©rit√©s al√©atoirement des parents</p>
                        </div>
                        <div class="mechanic-item">
                            <h4>Power Item</h4>
                            <p>Garantit l'IV correspondant du parent qui le tient</p>
                        </div>
                        <div class="mechanic-item">
                            <h4>2 Power Items</h4>
                            <p>50% de chance qu'un seul s'active (al√©atoire)</p>
                        </div>
                        <div class="mechanic-item">
                            <h4>IVs Al√©atoires</h4>
                            <p>1/32 chance d'√™tre 31</p>
                        </div>
                    </div>
                </div>

                <div class="instructions">
                    <h3>Nouvelle philosophie : Tous les M√©tamorph comptent !</h3>
                    <ul>
                        <li><strong>31 = 1</strong>, mais les autres IVs ne sont pas ignor√©s</li>
                        <li>Les M√©tamorph sans 31 peuvent √™tre utiles dans certaines strat√©gies</li>
                        <li>Les IVs al√©atoires ont une chance d'√™tre 31 (1/32)</li>
                        <li>Objectif : maximiser les chances d'obtenir des ≈ìufs avec des 31</li>
                    </ul>
                </div>

                <div class="import-export">
                    <h4>üìÅ Import/Export</h4>
                    <p>Importez ou exportez vos M√©tamorph en format JSON</p>
                    <div class="import-export-buttons">
                        <button class="btn-export" onclick="exportDittos()">üì§ Exporter</button>
                        <button class="btn-import" onclick="importDittos()">üì• Importer</button>
                    </div>
                </div>

                <div class="ditto-counter">
                    M√©tamorph valides: <span id="validDittosCount">0</span> / 30 maximum utilis√©s
                </div>

                <div class="ditto-grid" id="dittoGrid">
                    <!-- Les cartes M√©tamorph seront g√©n√©r√©es ici par JavaScript -->
                </div>

                <div class="buttons">
                    <button class="btn-optimize" onclick="optimizePairs()">
                        üöÄ Optimiser les couples
                    </button>
                    <button class="btn-reset" onclick="resetAll()">
                        üîÑ Tout r√©initialiser
                    </button>
                </div>
            </div>

            <div class="results-section">
                <h2>üí° R√©sultats d'optimisation</h2>
                <div class="optimization-info" id="optimizationInfo">
                    <div class="info-item">
                        <span class="info-label">M√©tamorph valides:</span>
                        <span id="validDittosCountResult">0</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Couples form√©s:</span>
                        <span id="couplesCount">0</span>
                    </div>
                </div>
                <div class="results-container" id="resultsContainer">
                    <div class="loading" id="loadingMessage">
                        Cliquez sur "Optimiser les couples" pour voir les r√©sultats...
                    </div>
                </div>
            </div>
        </div>

        <footer class="footer">
            <p>Optimiseur Cobblemon - Optimis√© pour les m√©caniques sp√©cifiques de votre serveur</p>
        </footer>
    </div>

    <script>
        class CobblemonOptimizer {
            constructor() {
                this.dittos = [];
                this.maxDittos = 60;
                this.maxUsedDittos = 30;
                this.maxPairs = 15;
                this.RANDOM_31_CHANCE = 1/32;
                this.init();
            }

            init() {
                this.createDittoGrid();
                this.loadFromStorage();
                this.updateDisplay();
            }

            createDittoGrid() {
                const grid = document.getElementById('dittoGrid');
                grid.innerHTML = '';

                for (let i = 0; i < this.maxDittos; i++) {
                    const dittoCard = this.createDittoCard(i);
                    grid.appendChild(dittoCard);
                }
            }

            createDittoCard(index) {
                const card = document.createElement('div');
                card.className = 'ditto-card';
                card.innerHTML = `
                    <h3>M√©tamorph #${index + 1}</h3>
                    <div class="iv-inputs">
                        ${this.createIVInputs(index)}
                    </div>
                `;
                return card;
            }

            createIVInputs(dittoIndex) {
                const stats = ['HP', 'Attaque', 'Defense', 'Attaque Sp√©.', 'Defense Sp√©.', 'Vitesse'];
                return stats.map((stat, statIndex) => `
                    <div class="iv-input">
                        <label>${stat}</label>
                        <input type="number" min="0" max="31" value="0" 
                               data-ditto="${dittoIndex}" data-stat="${statIndex}"
                               onchange="optimizer.updateDitto(${dittoIndex}, ${statIndex}, this.value)"
                               oninput="this.value = Math.max(0, Math.min(31, parseInt(this.value) || 0))">
                    </div>
                `).join('');
            }

            updateDitto(dittoIndex, statIndex, value) {
                if (!this.dittos[dittoIndex]) {
                    this.dittos[dittoIndex] = [0, 0, 0, 0, 0, 0];
                }
                
                const ivValue = Math.max(0, Math.min(31, parseInt(value) || 0));
                this.dittos[dittoIndex][statIndex] = ivValue;
                
                const input = document.querySelector(`input[data-ditto="${dittoIndex}"][data-stat="${statIndex}"]`);
                if (input) input.value = ivValue;
                
                this.saveToStorage();
                this.updateDisplay();
            }

            getAllDittos() {
                const validDittos = [];
                
                for (let i = 0; i < this.dittos.length; i++) {
                    if (this.dittos[i]) {
                        // Convertir en binaire : 31 = 1, autre = 0
                        const binaryIVs = this.dittos[i].map(iv => iv === 31 ? 1 : 0);
                        const binaryString = binaryIVs.map(iv => iv ? '1' : '0').join('');
                        const has31 = this.dittos[i].some(iv => iv === 31);
                        
                        validDittos.push({
                            ivs: this.dittos[i],
                            binaryIVs: binaryIVs,
                            originalIVs: [...this.dittos[i]],
                            binaryString: binaryString,
                            index: i,
                            score: this.calculateIndividualScore(this.dittos[i]),
                            has31: has31
                        });
                    }
                }
                
                return validDittos;
            }

            calculateIndividualScore(ivs) {
                // Score bas√© sur la somme des IVs + bonus pour les 31
                let score = ivs.reduce((sum, iv) => sum + iv, 0);
                score += ivs.filter(iv => iv === 31).length * 10; // Bonus pour chaque 31
                return score;
            }

            // STRAT√âGIES OPTIMIS√âES - CORRIG√âES
            findOptimalStrategy(ditto1, ditto2) {
                const stats = ['HP', 'Attaque', 'Defense', 'Attaque Sp√©.', 'Defense Sp√©.', 'Vitesse'];
                
                // Identifier les 31
                const ditto131 = [];
                const ditto231 = [];
                
                for (let i = 0; i < 6; i++) {
                    if (ditto1.ivs[i] === 31) ditto131.push(i);
                    if (ditto2.ivs[i] === 31) ditto231.push(i);
                }

                // Stats exclusives (31 sur un seul parent)
                const exclusive31_ditto1 = ditto131.filter(stat => !ditto231.includes(stat));
                const exclusive31_ditto2 = ditto231.filter(stat => !ditto131.includes(stat));

                // Total des 31 disponibles (stats avec au moins un 31)
                const total31 = [...new Set([...ditto131, ...ditto231])].length;

                let bestStrategy = null;

                // STRAT√âGIE 1: Destiny Knot + Power Item (TOUJOURS PRIVIL√âGI√âE)
                // Cette strat√©gie donne le meilleur r√©sultat : 1 IV garanti + 4 h√©rit√©s + 1 al√©atoire
                for (const exclusive of [...exclusive31_ditto1, ...exclusive31_ditto2]) {
                    const parentHas31 = exclusive31_ditto1.includes(exclusive) ? 'ditto1' : 'ditto2';
                    
                    // Avec DK + Power Item: 1 garanti + 4 h√©rit√©s parmi les autres stats avec 31 + 1 al√©atoire
                    const other31 = total31 - 1; // On exclut la stat garantie
                    const expectedInherited = Math.min(4, other31);
                    const expected = 1 + expectedInherited + this.RANDOM_31_CHANCE;
                    
                    const strategy = {
                        type: 'destinyknot_poweritem',
                        item1: parentHas31 === 'ditto1' ? this.getPowerItemForStat(exclusive) : 'destinyknot',
                        item2: parentHas31 === 'ditto2' ? this.getPowerItemForStat(exclusive) : 'destinyknot',
                        expected31: expected,
                        explanation: `Power Item garantit le 31 en ${stats[exclusive]} + Destiny Knot transmet ${expectedInherited} autres 31 + 1 al√©atoire`,
                        score: expected
                    };
                    
                    if (!bestStrategy || expected > bestStrategy.expected31) {
                        bestStrategy = strategy;
                    }
                }

                // Si on a trouv√© une strat√©gie DK + Power Item, on la retourne imm√©diatement
                if (bestStrategy) {
                    return bestStrategy;
                }

                // STRAT√âGIE 2: Destiny Knot seul (quand pas de stats exclusives)
                const dkExpected = Math.min(5, total31) + this.RANDOM_31_CHANCE;
                bestStrategy = {
                    type: 'destinyknot_only',
                    item1: 'destinyknot',
                    item2: null,
                    expected31: dkExpected,
                    explanation: `Destiny Knot seul: ${Math.min(5, total31)} IVs h√©rit√©s + 1 al√©atoire`,
                    score: dkExpected
                };

                // STRAT√âGIE 3: Deux Power Items (M√âCANIQUE SP√âCIFIQUE DU SERVEUR)
                // Seulement si meilleur que Destiny Knot seul
                if (exclusive31_ditto1.length >= 1 && exclusive31_ditto2.length >= 1) {
                    const stat1 = exclusive31_ditto1[0];
                    const stat2 = exclusive31_ditto2[0];
                    
                    // 50% chance pour chaque Power Item + 4 h√©rit√©s + 1 al√©atoire
                    const expectedWhenStat1 = 1 + Math.min(4, total31 - 1) + this.RANDOM_31_CHANCE;
                    const expectedWhenStat2 = 1 + Math.min(4, total31 - 1) + this.RANDOM_31_CHANCE;
                    const expected = 0.5 * expectedWhenStat1 + 0.5 * expectedWhenStat2;
                    
                    if (expected > bestStrategy.expected31) {
                        bestStrategy = {
                            type: 'two_poweritems_server',
                            item1: this.getPowerItemForStat(stat1),
                            item2: this.getPowerItemForStat(stat2),
                            expected31: expected,
                            explanation: `50% chance de garantir ${stats[stat1]} OU ${stats[stat2]} + 4 autres IVs h√©rit√©s + 1 al√©atoire`,
                            score: expected
                        };
                    }
                }

                // STRAT√âGIE 4: Power Item seul (TR√àS RARE - seulement si vraiment meilleur)
                for (const exclusive of [...exclusive31_ditto1, ...exclusive31_ditto2]) {
                    const parentHas31 = exclusive31_ditto1.includes(exclusive) ? 'ditto1' : 'ditto2';
                    
                    // Power Item seul: 1 garanti + 2 h√©rit√©s + 3 al√©atoires
                    const other31 = total31 - 1;
                    const expected = 1 + Math.min(2, other31) + (3 * this.RANDOM_31_CHANCE);
                    
                    // Seulement si significativement meilleur
                    if (expected > bestStrategy.expected31 + 0.5) { // Seuil plus √©lev√©
                        bestStrategy = {
                            type: 'poweritem_only',
                            item1: parentHas31 === 'ditto1' ? this.getPowerItemForStat(exclusive) : null,
                            item2: parentHas31 === 'ditto2' ? this.getPowerItemForStat(exclusive) : null,
                            expected31: expected,
                            explanation: `Garantit le 31 en ${stats[exclusive]} + 2 IVs h√©rit√©s + 3 al√©atoires`,
                            score: expected
                        };
                    }
                }

                // STRAT√âGIE 5: Aucun objet (pour M√©tamorph sans 31)
                if (!ditto1.has31 && !ditto2.has31) {
                    // 3 IVs h√©rit√©s + 3 al√©atoires
                    const expectedRandom = Math.min(3, total31) + (3 * this.RANDOM_31_CHANCE);
                    bestStrategy = {
                        type: 'no_items',
                        item1: null,
                        item2: null,
                        expected31: expectedRandom,
                        explanation: 'Aucun objet: 3 IVs h√©rit√©s + 3 al√©atoires',
                        score: expectedRandom
                    };
                }

                return bestStrategy;
            }

            getPowerItemForStat(statIndex) {
                const powerItems = [
                    'powerweight',    // HP
                    'powerbracer',    // Attaque
                    'powerbelt',      // D√©fense
                    'powerlens',      // Attaque Sp√©ciale
                    'powerband',      // D√©fense Sp√©ciale
                    'poweranklet'     // Vitesse
                ];
                return powerItems[statIndex];
            }

            optimizePairs() {
                try {
                    console.log("D√©but de l'optimisation...");
                    
                    const allDittos = this.getAllDittos();
                    const totalDittos = allDittos.length;
                    
                    console.log(`M√©tamorph valides: ${totalDittos}`);
                    
                    if (totalDittos < 2) {
                        this.showResults([], [], totalDittos);
                        alert('‚ùå Veuillez entrer au moins 2 M√©tamorph !');
                        return;
                    }

                    this.showLoading();

                    setTimeout(() => {
                        try {
                            let selectedDittos = allDittos;
                            if (totalDittos > this.maxUsedDittos) {
                                selectedDittos = allDittos
                                    .sort((a, b) => b.score - a.score)
                                    .slice(0, this.maxUsedDittos);
                            }

                            console.log(`M√©tamorph s√©lectionn√©s: ${selectedDittos.length}`);

                            const usedIndices = new Set(selectedDittos.map(d => d.index));
                            const unusedDittos = allDittos.filter(d => !usedIndices.has(d.index));

                            const pairs = this.findBestPairs(selectedDittos);
                            console.log(`Couples form√©s: ${pairs.length}`);
                            
                            this.showResults(pairs, unusedDittos, selectedDittos.length);
                        } catch (e) {
                            console.error("Erreur dans l'optimisation:", e);
                            this.showError("Erreur lors de l'optimisation: " + e.message);
                        }
                    }, 100);
                } catch (e) {
                    console.error("Erreur g√©n√©rale:", e);
                    this.showError("Erreur g√©n√©rale: " + e.message);
                }
            }

            findBestPairs(dittos) {
                const pairs = [];
                const usedIndices = new Set();
                const allPairs = [];
                
                console.log("G√©n√©ration des couples...");
                
                for (let i = 0; i < dittos.length; i++) {
                    for (let j = i + 1; j < dittos.length; j++) {
                        const ditto1 = dittos[i];
                        const ditto2 = dittos[j];
                        
                        const strategy = this.findOptimalStrategy(ditto1, ditto2);
                        
                        allPairs.push({
                            ditto1: { ...ditto1, item: strategy.item1 },
                            ditto2: { ...ditto2, item: strategy.item2 },
                            strategy: strategy,
                            score: strategy.score
                        });
                    }
                }
                
                console.log(`Couples g√©n√©r√©s: ${allPairs.length}`);
                
                allPairs.sort((a, b) => b.score - a.score);
                
                for (const pair of allPairs) {
                    if (pairs.length >= this.maxPairs) break;
                    
                    if (!usedIndices.has(pair.ditto1.index) && !usedIndices.has(pair.ditto2.index)) {
                        pairs.push(pair);
                        usedIndices.add(pair.ditto1.index);
                        usedIndices.add(pair.ditto2.index);
                    }
                }
                
                return pairs;
            }

            showLoading() {
                const container = document.getElementById('resultsContainer');
                container.innerHTML = `
                    <div class="loading">
                        <div>üîç Analyse des M√©tamorph...</div>
                        <div>Optimisation bas√©e sur les m√©caniques sp√©cifiques du serveur</div>
                    </div>
                `;
            }

            showError(message) {
                const container = document.getElementById('resultsContainer');
                container.innerHTML = `
                    <div class="error-message">
                        <strong>‚ùå Erreur</strong><br>
                        ${message}
                    </div>
                `;
            }

            showResults(pairs, unusedDittos, usedCount) {
                const container = document.getElementById('resultsContainer');
                const totalDittos = this.getAllDittos().length;
                
                document.getElementById('couplesCount').textContent = pairs.length;
                
                if (pairs.length === 0) {
                    container.innerHTML = `
                        <div class="loading">
                            ‚ùå Aucun couple optimal trouv√©.<br>
                            V√©rifiez que vous avez saisi au moins 2 M√©tamorph.
                        </div>
                    `;
                    return;
                }
                
                let html = '';
                
                if (totalDittos > this.maxUsedDittos) {
                    html += `
                        <div class="selection-info">
                            <strong>‚ÑπÔ∏è S√©lection automatique</strong><br>
                            Sur ${totalDittos} M√©tamorph valides, les ${usedCount} meilleurs ont √©t√© s√©lectionn√©s pour l'optimisation.
                        </div>
                    `;
                }
                
                html += `<div class="results-summary">
                    <h3>üéØ ${pairs.length} meilleur(s) couple(s) trouv√©(s)</h3>
                </div>`;
                
                pairs.forEach((pair, index) => {
                    html += this.createPairCard(pair, index + 1);
                });

                html += this.createItemsSummary(pairs);
                
                if (unusedDittos.length > 0) {
                    html += `<div class="unused-ditto">
                        <h4>üì¶ M√©tamorph non utilis√©s (${unusedDittos.length})</h4>
                        <p>Ces M√©tamorph n'ont pas √©t√© s√©lectionn√©s pour former des couples :</p>
                        <div style="margin-top: 10px; font-size: 0.9em;">
                            ${unusedDittos.map(d => `M√©tamorph #${d.index + 1} (${d.has31 ? d.score + '√ó31' : 'sans 31'})`).join(', ')}
                        </div>
                    </div>`;
                }
                
                container.innerHTML = html;
            }

            createItemsSummary(pairs) {
                const itemNames = {
                    'destinyknot': 'Destiny Knot',
                    'powerweight': 'Poids Pouvoir (HP)',
                    'powerbracer': 'Poignet Pouvoir (Attaque)',
                    'powerbelt': 'Ceinture Pouvoir (D√©fense)',
                    'powerlens': 'Lentille Pouvoir (Attaque Sp√©.)',
                    'powerband': 'Bandeau Pouvoir (D√©fense Sp√©.)',
                    'poweranklet': 'Gu√™tre Pouvoir (Vitesse)',
                    '': 'Aucun'
                };

                const itemUsage = {};
                pairs.forEach(pair => {
                    [pair.ditto1, pair.ditto2].forEach(ditto => {
                        if (ditto.item) {
                            itemUsage[ditto.item] = (itemUsage[ditto.item] || 0) + 1;
                        }
                    });
                });

                let itemsHtml = `<div class="items-summary">
                    <h4>üéÅ Objets recommand√©s</h4>
                    <p>Distribution optimale bas√©e sur les m√©caniques du serveur :</p>
                    <div class="items-grid">`;

                Object.keys(itemUsage).forEach(item => {
                    if (itemUsage[item] > 0) {
                        itemsHtml += `
                            <div class="item-assignment">
                                <h5>${itemNames[item]}</h5>
                                <div>Utilis√©: ${itemUsage[item]} fois</div>
                            </div>
                        `;
                    }
                });

                itemsHtml += `</div></div>`;
                return itemsHtml;
            }

            createPairCard(pair, pairNumber) {
                const itemNames = {
                    'destinyknot': 'Destiny Knot',
                    'powerweight': 'Poids Pouvoir (HP)',
                    'powerbracer': 'Poignet Pouvoir (Attaque)',
                    'powerbelt': 'Ceinture Pouvoir (D√©fense)',
                    'powerlens': 'Lentille Pouvoir (Attaque Sp√©.)',
                    'powerband': 'Bandeau Pouvoir (D√©fense Sp√©.)',
                    'poweranklet': 'Gu√™tre Pouvoir (Vitesse)',
                    '': 'Aucun'
                };

                const statNames = ['HP', 'Attaque', 'D√©fense', 'Attaque Sp√©.', 'D√©fense Sp√©.', 'Vitesse'];

                return `
                    <div class="couple-card">
                        <div class="couple-header">
                            <h3>Couple #${pairNumber}</h3>
                            <div class="couple-score">
                                ${pair.strategy.expected31.toFixed(2)}√ó31 attendus
                            </div>
                        </div>
                        <div class="parents">
                            ${this.createParentCard('Parent A', pair.ditto1)}
                            ${this.createParentCard('Parent B', pair.ditto2)}
                        </div>
                        <div class="couple-info">
                            <div><strong>Strat√©gie recommand√©e:</strong></div>
                            <div>
                                <span class="item-display">${itemNames[pair.ditto1.item] || 'Aucun'}</span> + 
                                <span class="item-display">${itemNames[pair.ditto2.item] || 'Aucun'}</span>
                            </div>
                            <div class="strategy-info">
                                <strong>${this.formatStrategyType(pair.strategy.type)}</strong><br>
                                ${pair.strategy.explanation}
                                <div class="probability-info">
                                    Optimis√© pour les m√©caniques sp√©cifiques du serveur
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            formatStrategyType(type) {
                const types = {
                    'destinyknot_only': 'DESTINY KNOT SEUL',
                    'destinyknot_poweritem': 'DESTINY KNOT + POWER ITEM',
                    'two_poweritems_server': 'DEUX POWER ITEMS (M√âCANIQUE SERVEUR)',
                    'poweritem_only': 'POWER ITEM SEUL',
                    'no_items': 'AUCUN OBJET'
                };
                return types[type] || type.toUpperCase();
            }

            createParentCard(title, ditto) {
                const stats = ['HP', 'Attaque', 'Defense', 'Attaque Sp√©.', 'Defense Sp√©.', 'Vitesse'];
                
                const ivDisplays = ditto.originalIVs.map((iv, index) => {
                    const className = iv === 31 ? 'iv-31' : 'iv-other';
                    return `
                        <div class="iv-value ${className}">
                            ${stats[index]}: ${iv}
                        </div>
                    `;
                }).join('');
                
                const warning = !ditto.has31 ? '<div class="no-31-warning">‚ö†Ô∏è Aucun 31 - Utile pour les IVs al√©atoires</div>' : '';
                
                return `
                    <div class="parent">
                        <h4>${title} (M√©tamorph #${ditto.index + 1})</h4>
                        <div>${ditto.has31 ? ditto.binaryIVs.reduce((a, b) => a + b, 0) + '√ó31' : 'Aucun 31'}</div>
                        <div class="binary-display" title="Repr√©sentation binaire: 1=31, 0=autre">
                            ${ditto.binaryString}
                        </div>
                        ${warning}
                        <div class="iv-display">
                            ${ivDisplays}
                        </div>
                    </div>
                `;
            }

            // Import/Export JSON
            exportToJSON() {
                const dittosData = this.dittos.map((ditto, index) => ({
                    id: index + 1,
                    ivs: ditto || [0, 0, 0, 0, 0, 0]
                }));
                return JSON.stringify(dittosData, null, 2);
            }

            importFromJSON(jsonData) {
                try {
                    const data = JSON.parse(jsonData);
                    const newDittos = [];
                    
                    for (let i = 0; i < this.maxDittos; i++) {
                        if (i < data.length) {
                            newDittos[i] = data[i].ivs;
                        } else {
                            newDittos[i] = [0, 0, 0, 0, 0, 0];
                        }
                    }
                    
                    this.dittos = newDittos;
                    this.createDittoGrid();
                    this.saveToStorage();
                    this.updateDisplay();
                    
                    return true;
                } catch (e) {
                    console.error("Erreur d'import JSON:", e);
                    return false;
                }
            }

            resetAll() {
                this.dittos = [];
                this.createDittoGrid();
                this.saveToStorage();
                this.updateDisplay();
                
                const container = document.getElementById('resultsContainer');
                container.innerHTML = `
                    <div class="loading">
                        Cliquez sur "Optimiser les couples" pour voir les r√©sultats...
                    </div>
                `;
            }

            updateDisplay() {
                const validCount = this.getAllDittos().length;
                document.getElementById('validDittosCount').textContent = validCount;
                document.getElementById('validDittosCountResult').textContent = validCount;
            }

            saveToStorage() {
                localStorage.setItem('cobblemonOptimizer_dittos', JSON.stringify(this.dittos));
            }

            loadFromStorage() {
                try {
                    const savedDittos = localStorage.getItem('cobblemonOptimizer_dittos');
                    if (savedDittos) {
                        this.dittos = JSON.parse(savedDittos);
                        
                        for (let i = 0; i < this.dittos.length; i++) {
                            if (this.dittos[i]) {
                                for (let j = 0; j < 6; j++) {
                                    const input = document.querySelector(`input[data-ditto="${i}"][data-stat="${j}"]`);
                                    if (input) input.value = this.dittos[i][j] || 0;
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.error("Erreur lors du chargement:", e);
                }
                
                this.updateDisplay();
            }
        }

        // Initialiser l'optimiseur
        const optimizer = new CobblemonOptimizer();

        // Fonctions globales
        function optimizePairs() {
            optimizer.optimizePairs();
        }

        function resetAll() {
            optimizer.resetAll();
        }

        function exportDittos() {
            const jsonData = optimizer.exportToJSON();
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'metamorph-data.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function importDittos() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const success = optimizer.importFromJSON(e.target.result);
                        if (success) {
                            alert('‚úÖ M√©tamorph import√©s avec succ√®s !');
                        } else {
                            alert('‚ùå Erreur lors de l\'import. V√©rifiez le format du fichier.');
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }
    </script>
</body>
</html>
